# syntax: proto3
using ProtoBuf
import ProtoBuf.meta

# ValueType describes the semantics and measurement units of a value.
mutable struct ValueType <: ProtoType
    _type::Int64  # Index into string table.
    unit::Int64  # Index into string table.
    ValueType(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct ValueType

mutable struct Label <: ProtoType
    key::Int64  # Index into string table
    # At most one of the following must be present
    str::Int64  # Index into string table
    num::Int64
    # Should only be present when num is present.
    # Specifies the units of num.
    # Use arbitrary string (for example, "requests") as a custom count unit.
    # If no unit is specified, consumer may apply heuristic to deduce the unit.
    # Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    # units and units like "seconds" and "nanoseconds" as time units,
    # and apply appropriate unit conversions to these.
    num_unit::Int64  # Index into string table
    Label(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Label

# Each Sample records values encountered in some program
# context. The program context is typically a stack trace, perhaps
# augmented with auxiliary information like the thread-id, some
# indicator of a higher level request being handled etc.
mutable struct Sample <: ProtoType
    # The ids recorded here correspond to a Profile.location.id.
    # The leaf is at location_id[0].
    location_id::Base.Vector{UInt64}
    # The type and unit of each value is defined by the corresponding
    # entry in Profile.sample_type. All samples must have the same
    # number of values, the same as the length of Profile.sample_type.
    # When aggregating multiple samples into a single sample, the
    # result has a list of values that is the elemntwise sum of the
    # lists of the originals.
    value::Base.Vector{Int64}
    # label includes additional context for this sample. It can include
    # things like a thread id, allocation size, etc
    label::Base.Vector{Label}
    Sample(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Sample
const __pack_Sample = Symbol[:location_id,:value]
meta(t::Type{Sample}) = meta(t, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, true, __pack_Sample, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES, ProtoBuf.DEF_FIELD_TYPES)

mutable struct Mapping <: ProtoType
    # Unique nonzero id for the mapping.
    id::UInt64
    # Address at which the binary (or DLL) is loaded into memory.
    memory_start::UInt64
    # The limit of the address range occupied by this mapping.
    memory_limit::UInt64
    # Offset in the binary that corresponds to the first mapped address.
    file_offset::UInt64
    # The object this entry is loaded from.  This can be a filename on
    # disk for the main binary and shared libraries, or virtual
    # abstractions like "[vdso]".
    filename::Int64  # Index into string table
    # A string that uniquely identifies a particular program version
    # with high probability. E.g., for binaries generated by GNU tools,
    # it could be the contents of the .note.gnu.build-id field.
    build_id::Int64  # Index into string table
    # The following fields indicate the resolution of symbolic info.
    has_functions::Bool
    has_filenames::Bool
    has_line_numbers::Bool
    has_inline_frames::Bool
    Mapping(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Mapping

mutable struct Line <: ProtoType
    # The id of the corresponding profile.Function for this line.
    function_id::UInt64
    # Line number in source code.
    line::Int64
    Line(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Line

# Describes function and line table debug information.
mutable struct Location <: ProtoType
    # Unique nonzero id for the location.  A profile could use
    # instruction addresses or any integer sequence as ids.
    id::UInt64
    # The id of the corresponding profile.Mapping for this location.
    # It can be unset if the mapping is unknown or not applicable for
    # this profile type.
    mapping_id::UInt64
    # The instruction address for this location, if available.  It
    # should be within [Mapping.memory_start...Mapping.memory_limit]
    # for the corresponding mapping. A non-leaf address may be in the
    # middle of a call instruction. It is up to display tools to find
    # the beginning of the instruction if necessary.
    address::UInt64
    # Multiple line indicates this location has inlined functions,
    # where the last entry represents the caller into which the
    # preceding entries were inlined.
    # 
    # E.g., if memcpy() is inlined into printf:
    #    line[0].function_name == "memcpy"
    #    line[1].function_name == "printf"
    line::Base.Vector{Line}
    # Provides an indication that multiple symbols map to this location's
    # address, for example due to identical code folding by the linker. In that
    # case the line information above represents one of the multiple
    # symbols. This field must be recomputed when the symbolization state of the
    # profile changes.
    is_folded::Bool
    Location(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Location

mutable struct Function <: ProtoType
    # Unique nonzero id for the function.
    id::UInt64
    # Name of the function, in human-readable form if available.
    name::Int64  # Index into string table
    # Name of the function, as identified by the system.
    # For instance, it can be a C++ mangled name.
    system_name::Int64  # Index into string table
    # Source file containing the function.
    filename::Int64  # Index into string table
    # Line number in source file.
    start_line::Int64
    Function(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Function

mutable struct Profile <: ProtoType
    # A description of the samples associated with each Sample.value.
    # For a cpu profile this might be:
    #   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
    # For a heap profile, this might be:
    #   [["allocations","count"], ["space","bytes"]],
    # If one of the values represents the number of events represented
    # by the sample, by convention it should be at index 0 and use
    # sample_type.unit == "count".
    sample_type::Base.Vector{ValueType}
    # The set of samples recorded in this profile.
    sample::Base.Vector{Sample}
    # Mapping from address ranges to the image/binary/library mapped
    # into that address range.  mapping[0] will be the main binary.
    mapping::Base.Vector{Mapping}
    # Useful program location
    location::Base.Vector{Location}
    # Functions referenced by locations
    _function::Base.Vector{Function}
    # A common table for strings referenced by various messages.
    # string_table[0] must always be "".
    string_table::Base.Vector{AbstractString}
    # frames with Function.function_name fully matching the following
    # regexp will be dropped from the samples, along with their successors.
    drop_frames::Int64  # Index into string table.
    # frames with Function.function_name fully matching the following
    # regexp will be kept, even if it matches drop_functions.
    keep_frames::Int64  # Index into string table.

    # The following fields are informational, do not affect
    # interpretation of results.

    # Time of collection (UTC) represented as nanoseconds past the epoch.
    time_nanos::Int64
    # Duration of the profile, if a duration makes sense.
    duration_nanos::Int64
    # The kind of events between sampled ocurrences.
    # e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
    period_type::ValueType
    # The number of events between sampled occurrences.
    period::Int64
    # Freeform text associated to the profile.
    comment::Base.Vector{Int64}  # Indices into string table.
    # Index into the string table of the type of the preferred sample
    # value. If unset, clients should default to the last sample value.
    default_sample_type::Int64
    Profile(; kwargs...) = (o=new(); fillunset(o); isempty(kwargs) || ProtoBuf._protobuild(o, kwargs); o)
end #mutable struct Profile
const __pack_Profile = Symbol[:comment]
meta(t::Type{Profile}) = meta(t, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, true, __pack_Profile, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES, ProtoBuf.DEF_FIELD_TYPES)

export Profile, ValueType, Sample, Label, Mapping, Location, Line, Function
